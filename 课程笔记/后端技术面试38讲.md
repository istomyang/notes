# 课程笔记：后端技术面试38讲

可以再看一遍。

## 开篇词

如果你能建立起这套技术思维体系，掌握这套技术体系背后的原理，那么当你接触一个新技术的时候，就可以快速把握住这个新技术的本质特征和思路方法，然后用你的技术思维体系快速推导出这个新技术是如何实现的。这个时候你其实不需要去学习这个新技术了，而是去验证这个新技术，你会去看它的文档和代码，去验证它是不是和你推导、猜测的实现方式一致，而不是去学习它怎么用了。那么，学习一个新技术就变成了一个简单、轻松、快速且充满乐趣的过程了。你不再惧怕学习新技术，而是开始抱怨：为什么技术革新得这么慢，太无聊了。你甚至可以开始自己创造新技术。

第一性原理就是让我们抓住事物最本质的特征原理，依据事物本身的规律，去推导、分析、演绎事物的各种变化规律，进而洞悉事物在各种具体场景下的表现形式，而不是追随事物的表面现象，生搬硬套各种所谓的规矩、经验和技巧，以至于在各种纷繁复杂的冲突和纠结中迷失了方向。


## 软件基础原理

看原文。

## 软件设计原理

### 软件设计的方法论

软件模型：两个方面客观存在的抽象。一个是 要解决的领域问题，业务逻辑，另一个是 最终开发出来的软件系统，代码层次、多少台服务器、如何通信。

软件建模与设计：对领域问题和软件系统进行分析、设计和抽象的过程。

---

4+1 视图模型：软件建模方法的方法，即建模方法论。

- 逻辑视图：描述软件的功能逻辑，由哪些模块组成，模块中包含那些类，其依赖关系如何。

- 开发视图：包括系统架构层面的层次划分，包的管理，依赖的系统与第三方的程序包。开发视图某些方面和逻辑视图有一定重复性，不同视角看到的可能是同一个东西，开发视图中一个程序包，可能正好对应逻辑视图中的一个功能模块。

- 过程视图：描述程序运行期的进程、线程、对象实例，以及与此相关的并发、同步、通信等问题。

- 物理视图：描述软件如何安装并部署到物理的服务上，以及不同的服务器之间如何关联、通信。

- 场景视图：针对具体的用例场景，将上述 4 个视图关联起来，一方面从业务角度描述，功能流程如何完成，一方面从软件角度描述，相关组成部分如何互相依赖、调用。

---

UML 建模

进行软件建模画图的工具是 UML，统一建模语言。

所谓统一，指的是在 UML 之前，软件建模工具和方法有很多种，最后业界达成共识，用 UML 统一软件建模工具。

所谓建模，前面已经说过，就是用 UML 对领域业务问题和软件系统进行设计抽象，一个工具完成软件开发过程中的两个客观存在的建模。

所谓语言：用于交流、沟通、示意。


### 软件设计实践

图：

类图：描述类的特性和类之间的静态关系。主要是在详细设计阶段画。

序列图：类图描述类之间的静态关系，序列图则用来描述参与者之间的动态调用关系。

组件图：组件是比类粒度更大的设计元素，一个组件中通常包含很多个类。组件图有的时候和包图的用途比较接近，组件图通常用来描述物理上的组件，比如一个 JAR，一个 DLL 等等。一般用在概要设计阶段。

部署图：描述软件系统的最终部署情况，比如需要部署多少服务器，关键组件都部署在哪些服务器上。主要用在概要设计阶段。

用例图：主要用在需求分析阶段，通过反映用户和软件系统的交互，描述系统的功能需求。

状态图：用来展示单个对象生命周期的状态变迁。

活动图：主要用来描述过程逻辑和业务流程，用活动图代替流程图。

---

阶段：

- 在需求分析阶段，主要是通过用例图来描述系统的功能与使用场景；对于关键的业务流程，可以通过活动图描述；如果在需求阶段就提出要和现有的某些子系统整合，那么可以通过时序图描述新系统和原来的子系统的调用关系；可以通过简化的类图进行领域模型抽象，并描述核心领域对象之间的关系；如果某些对象内部会有复杂的状态变化，比如用户、订单这些，可以用状态图进行描述。

- 在概要设计阶段，通过部署图描述系统最终的物理蓝图；通过组件图以及组件时序图设计软件主要模块及其关系；还可以通过组件活动图描述组件间的流程逻辑。

- 在详细设计阶段，主要输出的就是类图和类的时序图，指导最终的代码开发，如果某个类方法内部有比较复杂的逻辑，那么可以用画方法的活动图进行描述。


### 软件设计目的

有人说，在软件开发中，优秀的程序员比糟糕的程序员的工作产出高 100 倍。这听起来有点夸张，实际上，我可能更悲观一点，就我看来，有时候，后者的工作成果可能是负向的，也就是说，因为他的工作，项目会变得更加困难，代码变得更加晦涩，难以维护，工期因此推延，各种莫名其妙改来改去的 bug 一再出现，而且这种局面还会蔓延扩散，连那些本来还好的代码模块也逐渐腐坏变烂，最后项目难以为继，以失败告终。

在软件设计开发这个领域，好的设计和坏的设计最大的差别就体现在应对需求变更的能力上。而好的程序员和差的程序员的一个重要区别，就是对待需求变更的态度。差的程序员害怕需求变更，因为每次针对需求变更而开发的代码都会导致无尽的 bug；好的程序员则欢迎需求变更，因为他们一开始就针对需求变更进行了软件设计，如果没有需求变更，他们优秀的设计就没有了用武之地，产生一拳落空的感觉。这两种不同态度的背后，是设计能力的差异。

一个优秀的程序员一旦习惯设计、编写能够灵活应对需求变更的代码，他就再也不会去编写那些僵化的、脆弱的、晦涩的代码了，甚至仅仅是看这样的代码，也会产生强烈的不舒服的感觉。记得一天下午，一个技术不错的同事突然跟我请假，说身体不舒服，需要回去休息一下，我看他脸色惨白，有气无力，就问他怎么了。他回答：刚才给另一个组的同事 review 代码，代码太恶心了，看到中途去厕所吐了，现在浑身难受，需要休息。

实际上，糟糕的代码就是能产生这么大的威力，这些代码在运行过程中使系统崩溃；测试过程中使 bug 无法收敛，越改越多；开发过程使开发者陷入迷宫，掉到一个又一个坑里；而仅仅是看这些代码，都会使阅读者头晕眼花。

---

糟糕设计的特征

- 僵化性：软件代码之间耦合严重，难以改动，任何微小的改动都会引起更大范围的改动。一个看似微小的需求变更，却发现需要在很多地方修改代码。

- 脆弱性：脆弱则是微小的改动容易引起莫名其妙的崩溃或者 bug，出现 bug 的地方看似与改动的地方毫无关联，或者软件进行了一个看似简单的改动，重新启动，然后就莫名其妙地崩溃了。

- 牢固性：指软件无法进行快速、有效地拆分。想要复用软件的一部分功能，却无法容易地将这部分功能从其他部分中分离出来。

	微服务是低耦合模块的服务化，首先需要的，就是低耦合的模块，然后才是微服务的架构。如果单体系统都做不到模块的低耦合，那么由此改造出来的微服务系统只会将问题加倍放大，最后就怪微服务了。

- 粘滞性：需求变更导致软件变更的时候，如果糟糕的代码变更方案比优秀的方案更容易实施，那么软件就会向糟糕的方向发展。
	
	很多软件在设计之初有着良好的设计，但是随着一次一次的需求变更，最后变得千疮百孔，趋向腐坏。

- 晦涩性：如果代码晦涩难懂，必然会导致代码的维护者以设计者不期望的方式对代码进行修改，导致系统腐坏变质。

**应对需求变更最好的办法就是一开始的设计就是针对需求变更的，并在开发过程中根据真实的需求变更不断重构代码，保持代码对需求变更的灵活性。**


### 软件设计的开闭原则

软件实体（模块、类、函数等等）应该对扩展是开放的，对修改是关闭的。

举个例子，一个 Button按钮，刚开始是拨号器按钮，后来是密码锁按钮，如果违反开闭原则，就会导致每次都要去修改内部函数。开闭原则就是：对功能扩展是开放的，对代码修改是关闭的。

当我们在代码中看到 else 或者 switch/case 关键字的时候，基本可以判断违反开闭原则了。

实现方法：

- 使用策略模式实现开闭原则：使用 接口 把业务执行代码暴露出来用于扩展，然后多个策略实现同一个策略接口。

- 使用适配器模式实现开闭原则：适配器模式是一种结构模式，用于将两个不匹配的接口适配起来，使其能够正常工作。比如：一个 类A 实现某个接口，但是需要区分多种情况，内部肯定有多个 If 语句，现在使用 Adapter 去实现接口，然后 Adapter 依赖 类A，去调用类 A 相应的方法。

- 使用观察者模式实现开闭原则：Listener，观察者模式是一种行为模式，解决一对多的对象依赖关系，将被观察者对象的行为通知到多个观察者，也就是监听者对象。

- 使用模板方法模式实现开闭原则：在父类中用抽象方法定义计算的骨架和过程，而抽象方法的实现则留在子类中。

实现开闭原则的关键是抽象。当一个模块依赖的是一个抽象接口的时候，就可以随意对这个抽象接口进行扩展，这个时候，不需要对现有代码进行任何修改，利用接口的多态性，通过增加一个新实现该接口的实现类，就能完成需求变更。

大部分的设计模式都是用来解决扩展的灵活性问题的。


### 软件设计的依赖倒置原则

依赖倒置高层模块不应该依赖低层模块，二者都应该依赖抽象。抽象不应该依赖具体实现，具体实现应该依赖抽象。某些框架就是，不需要你去调用它，它会调用你，就是你编写它给你设计的接口。

### 软件设计的里氏替换原则

里氏替换子类型必须能够替换掉它们的基类型。程序中，所有使用基类的地方，都应该可以用子类代替。

一个类如果不是为了被继承而设计，那么最好就不要继承它。粗暴一点地说，如果不是抽象类或者接口，最好不要继承它。

【 你可以使用接口组合创建庞大的接口，但一个类必须只能继承接口，一个实体类不能继承另一个实体类。】

如果你确实需要使用一个类的方法，最好的办法是组合这个类而不是继承这个类，这就是人们通常说的组合优于继承。

### 软件设计的单一职责原则

单一职责内聚性主要研究组成一个模块或者类的内部元素的功能相关性。

一个类，应该只有一个引起它变化的原因。这就是软件设计的单一职责原则。

如果一个类承担的职责太多，就等于把这些职责都耦合在一起。这种耦合会导致类很脆弱：当变化发生的时候，会引起类不必要的修改，进而导致 bug 出现。

### 软件设计的接口隔离原则

接口隔离原则说：不应该强迫用户依赖他们不需要的方法。

用接口隐藏一些不想让用户知道的。

接口隔离原则，我们可以将一个实现类的不同方法包装在不同的接口中对外暴露。

### 16设计模式基础

面向对象编程的本质是多态。

在面向对象的编程语言中，多态非常简单：子类实现父类或者接口的抽象方法，程序使用抽象父类或者接口编程，运行期注入不同的子类，程序就表现出不同的形态，是为多态。设计模式的精髓是对多态的使用。

### 17设计模式应用

讲述框架所使用的设计模式，无笔记。

### 反应式编程框架设计

反应式编程本质上是一种异步编程方案，在多线程（协程）、异步方法调用、异步 I/O 访问等技术基础之上，提供了一整套与异步调用相匹配的编程模型，从而实现程序调用非阻塞、即时响应等特性，即开发出一个反应式的系统，以应对编程领域越来越高的并发处理需求。

反应式特性：

- 即时响应，应用的调用者可以即时得到响应，无需等到整个应用程序执行完毕。也就是说应用调用是非阻塞的。

- 回弹性，当应用程序部分功能失效的时候，应用系统本身能够进行自我修复，保证正常运行，保证响应，不会出现系统崩溃和宕机的情况。

- 弹性，系统能够对应用负载压力做出响应，能够自动伸缩以适应应用负载压力，根据压力自
- 动调整自身的处理能力，或者根据自身的处理能力，调整进入系统中的访问请求数量。

- 消息驱动，功能模块之间，服务之间，通过消息进行驱动，完成服务的流程。

目前主流的反应式编程框架有 RxJava、Reactor 等，它们的主要特点是基于观察者设计模式的异步编程方案，编程模型采用函数式编程。

### 组件设计原则

组件内聚原则：主要讨论哪些类应该聚合在同一个组件中，以便组件既能提供相对完整的功能，又不至于太过庞大。在具体设计中，可以遵循以下三个原则：

1. 复用发布等同原则：软件复用的最小粒度应该等同于其发布的最小粒度。也就是说，如果你希望别人以怎样的粒度复用你的软件，你就应该以怎样的粒度发布你的软件。这其实就是组件的定义了，组件是软件复用和发布的最小粒度软件单元。这个粒度既是复用的粒度，也是发布的粒度。

2. 共同封闭原则：应该将那些会同时修改，并且为了相同目的而修改的类放到同一个组件中。而将不会同时修改，并且不会为了相同目的而修改的类放到不同的组件中。

	组件的目的虽然是为了复用，然而开发中常常引发问题的，恰恰在于组件本身的可维护性。如果组件在自己的生命周期中必须经历各种变更，那么最好不要涉及其他组件，相关的变更都在同一个组件中。这样，当变更发生的时候，只需要重新发布这个组件就可以了，而不是一大堆组件都受到牵连。

3. 共同复用原则：不要强迫一个组件的用户依赖他们不需要的东西。

---

组件耦合原则：讨论组件之间的耦合关系应该如何设计。

1. 无循环依赖原则：组件依赖关系中不应该出现环。

2. 稳定依赖原则：组件依赖关系必须指向更稳定的方向。不稳定的组件应该依赖稳定的组件。

3. 稳定抽象原则：一个组件的抽象化程度应该与其稳定性程度一致。一个稳定的组件应该是抽象的，而不稳定的组件应该是具体的。—— 使用依赖倒置。

### 领域驱动设计

如果你对自己要开发的业务领域没有清晰的定义和边界，没有设计系统的领域模型，而仅仅跟着所谓的需求不断开发功能，一旦需求来自多个方面，就可能发生需求冲突，或者随着时间的推移，前后功能也会发生冲突，这时你越是试图弥补这些冲突，就越是陷入更大的冲突之中。

回想一下我经历的各种项目，似乎确实如此。用户或者产品经理的需求零零散散，不断变更。工程师在各处代码中寻找可以实现这些需求变更的代码，修修补补。软件只有需求分析，并没有真正的设计，系统没有一个统一的领域模型维持其内在的逻辑一致性。功能特性并不是按照领域模型内在的逻辑设计，而是按照各色人等自己的主观想象设计。项目时间一长，各种困难重重，需求不断延期，线上 bug 不断，管理者考虑是不是要推到重来，而程序员则考虑是不是要跑路。

---

事务脚本/贫血模型

目前企业级应用开发中，业务逻辑的组织方式主要是 事务脚本模式。

事务脚本按照业务处理的过程组织业务逻辑，每个过程处理来自客户端的单个请求。

事务脚本模式：Controller→Service→Dao：Controller 封装用户请求，根据请求参数构造一些数据对象调用 Service，Service 里面包含大量的业务逻辑代码，完成对数据的处理，期间可能需要通过 Dao 从数据库中获取数据，或者将数据写入数据库中。

事务脚本模式中，Service、Dao 这些对象只有方法，没有数值成员变量，而方法调用时传递的数值对象没有方法，因此事务脚本又被称作贫血模型。

---

领域模型/充血模型

在领域模型模式下，业务逻辑围绕领域模型设计。比如收入确认是和合同强相关的，是合同对象的一个职责，那么合同对象就应该提供一个 calculateRecognition 方法计算收入。

领域模型的对象则包含了对象的数据和计算逻辑。

设计好了领域模型对象，也就设计好了业务逻辑实现。和事务脚本被称作贫血模型相对应的，领域模型也被称为充血模型。

使用领域模型增加新的产品类型的时候，就不需要修改现有的代码，只需要扩展新的产品类和收入策略类就可以了。

在需求变更过程中，如果一个需求和领域模型有冲突，和模型的定义以及模型间的交互逻辑不一致，那么很有可能这个需求本身就是伪需求。很多看似合理的需求其实和业务的内在逻辑是有冲突的，这样的需求也不会带来业务的价值，通过领域模型分析，可以识别出这样的伪需求，使系统更好地保持一致性，也可以使开发资源投入到更有价值的地方去。

---

领域驱动设计（DDD）

领域是一个组织所做的事情以及其包含的一切，通俗地说，就是组织的业务范围和做事方式，也是软件开发的目标范围。

领域驱动设计就是从领域出发，分析领域内模型及其关系，进而设计软件系统的方法。

通常的做法是把整个领域拆分成多个子域，比如用户、商品、订单、库存、物流、发票等。强相关的多个子域组成一个界限上下文，界限上下文是对业务领域范围的描述，对于系统实现而言，可以想象成相当于是一个子系统或者是一个模块。界限上下文和子域共同组成组织的领域。

不同的界限上下文，也就是不同的子系统或者模块之间会有各种的交互合作。DDD 使用上下文映射图来完成。

DDD 支持各种架构方案：分层架构、六边形架构

分层架构：领域实体被放置在领域层，通过应用层对领域实体进行包装，最终提供一组访问接口，通过接口层对外开放。

六边形架构：领域模型通过应用程序封装成一个相对比较独立的模块，而不同的外部系统则通过不同的适配器和领域模型交互

通过领域实体及其交互完成业务逻辑处理才是 DDD 的核心目标。

详细看原文。


## 软件架构原理

### 分布式架构

如何解决高并发的用户请求带来的问题：垂直伸缩与水平伸缩

垂直伸缩带来的价格成本和服务器的处理能力并不一定呈线性关系，也就是说，增加同样的费用，并不能得到同样的计算能力。而且计算能力越强大，需要花费的钱就越多。

水平伸缩，指的是不去提升单机的处理能力，不使用更昂贵更快更厉害的硬件，而是使用更多的服务器，将这些服务器构成一个分布式集群，通过这个集群，对外统一提供服务，以此来提高系统整体的处理能力。

要想让更多的服务器构成一个整体，就需要在架构上进行设计，让这些服务器成为整体系统的一个部分，将这些服务器有效地组织起来，统一提升系统的处理能力。

分布式架构方案：将一系列的分布式技术方案整合起来：分布式缓存、负载均衡、反向代理与 CDN、分布式消息队列、分布式数据库、NoSQL 数据库、分布式文件、搜索引擎、微服务等。

### 缓存架构

缓存可以分成两种，通读缓存和旁路缓存。

通读（read-through）缓存，应用程序访问通读缓存获取数据的时候，如果通读缓存有应用程序需要的数据，那么就返回这个数据；如果没有，那么通读缓存就自己负责访问数据源，从数据源获取数据返回给应用程序，并将这个数据缓存在自己的缓存中。比如 反向代理缓存、CDN。

旁路（cache-aside）缓存，应用程序访问旁路缓存获取数据的时候，如果旁路缓存中有应用程序需要的数据，那么就返回这个数据；如果没有，就返回空（null）。应用程序需要自己从数据源读取数据，然后将这个数据写入到旁路缓存中。

如果缓存的数据没有热点，写入缓存的数据很难被重复读取，那么使用缓存就不是很有必要了。

### 异步架构

使用消息队列实现异步架构

### 负载均衡架构

HTTP 重定向负载均衡

DNS 负载均衡

反向代理负载均衡

IP 负载均衡：负载均衡服务器会对网络层的数据包的 IP 地址进行转换，修改 IP 地址，将其修改为应用服务器的 IP 地址，然后把数据包重新发送出去，请求数据就会到达应用服务器。

数据链路层负载均衡：修改数据链路层里的网卡 mac 地址，在数据链路层实现负载均衡。目前大型互联网应用基本都使用链路层负载均衡。

Linux 上实现 IP 负载均衡和链路层负载均衡的技术是 LVS，目前 LVS 的功能已经集成到 Linux 中了，通过 Linux 可以直接配置实现这两种负载均衡。

### 数据存储架构

数据库主从复制：仅改善读的性能。

数据库分片：解决数据库的存储问题。

NoSQL 数据库：NoSQL 数据是改善数据存储能力的一个重要手段。

MongoDB。

### 搜索引擎架构

PageRank 算法：如果一个网页里包含了某个网页的超链接，那么就表示该网页认可某个网页，或者说，该网页给某个网页投了一票。

### 微服务架构

自己看

### 高性能架构

性能指标：响应时间、并发数、吞吐量和性能计数器。

性能计数器：指的是服务器或者操作系统性能的一些指标数据，包括系统负载 System Load、对象和线程数、内存使用、CPU 使用、磁盘和网络 I/O 使用等指标，这些指标是系统监控的重要参数，反映系统负载和处理能力的一些关键指标，通常这些指标和性能是强相关的。

---

性能测试：以系统设计初期规划的性能指标为预期目标，对系统不断地施加压力，验证系统在资源可接受的范围内是否达到了性能的预期目标。

负载测试：对系统不断地施加并发请求，增加系统的压力，直到系统的某项或多项指标达到安全临界值。这

压力测试：在超过安全负载的情况下，增加并发请求数，对系统继续施加压力，直到系统崩溃，或者不再处理任何请求，此时的并发数就是系统的最大压力承受能力。

---

性能优化

用户体验优化：除了用户体验优化这种比较主观的性能优化，即使我们想要真正优化性能指标，进行客观的性能优化。

数据中心优化：大型的互联网应用基本都采用多数据中心方案，在全球各个主要区域都部署自己的数据中心，就近为区域用户提供服务，加快响应速度。

硬件优化：垂直伸缩和水平伸缩，做 Spark 性能优化时发现，网络通信是整个计算作业的一个重要瓶颈点。

操作系统优化：不同操作系统以及操作系统内的某些特性也会对软件性能有重要影响。

虚拟机优化：JVM

基础组件优化：Web 容器，数据库连接池，MVC 框架等等。这些基础组件的性能也会对系统性能有较大影响。

架构优化：缓存、消息队列、集群。

代码优化：


### 高可用架构

高可用的度量：比如说淘宝的可用性是 4 个 9，就是说淘宝的服务 99.99% 可用。这句话的意思是，淘宝的服务要保证在所有的运行时间里只有 0.01% 不可用，也就是说一年大概有 53 分钟不可用。

冗余备份：负载均衡还可以实现系统的高可用。

失败隔离：失败隔离的主要架构技术是消息队列。

限流降级：非核心业务。系统高并发的时候，比如说像淘宝双 11 的时候，当天可能整天系统都处于一种极限的高并发访问压力之下，这时候就可以将确认收货、评价这些非核心的功能关闭，将宝贵的系统资源留下来，给正在购物的人，让他们去完成交易。

异地多活：异地多活的架构考虑的重点就是，用户请求如何分发到不同的机房去。这个主要可以在域名解析的时候完成，也就是用户进行域名解析的时候，会根据就近原则或者其他一些策略，完成用户请求的分发。另一个至关重要的技术点是，因为是多个机房都可以独立对外提供服务，所以也就意味着每个机房都要有完整的数据记录。用户在任何一个机房完成的数据操作，都必须同步传输给其他的机房，进行数据实时同步。


### 安全性架构

用户密码加密通常使用的是单向散列加密。

加密解密：

单向散列算法加密：适用于存储用户密码。还需要在计算过程中加点“盐”salt，如果黑客不知道加的“盐”是什么，就无法建立彩虹表，还原得到明文。

对称加密算法：适用于需要解密获得数据。用户的信用卡卡号，很多互联网电商网站支持用户使用信用卡进行支付。但如果直接把信用卡号、有效期、安全码存储在数据库中是比较危险的，所以必须对这些信息进行加密，在数据库中存储密文。但是在使用的时候又必须要对密文进行解密，还原得到明文，才能够正常使用。所以这个时候就要使用对称加密算法，在存储的时候使用加密算法进行加密，在使用的时候使用解密算法进行解密。

非对称加密：适用于判断身份。还可以实现数字签名。用数字签名的时候是反过来的，自己用私钥进行加密，得到一个密文，但是其他人可以用公钥将密文解开，因为私钥只有自己才拥有，所以等同于签名。一段经过自己私钥加密后的文本，文本内容就等于是自己签名认证过的。我在后面要讲到的区块链架构中，交易就使用非对称加密进行签名。

---

HTTP 攻击：SQL 注入攻击和 XSS 攻击。


### 大数据架构

大数据技术本质是把 数据处理 用到分布式技术上。

大数据就是将各种数据统一收集起来进行计算，发掘其中的价值。这些数据，既包括数据库的数据，也包括日志数据，还包括专门采集的用户行为数据；既包括企业内部自己产生的数据，也包括从第三方采购的数据，还包括使用网络爬虫获取的各种互联网公开数据。

分布式文件存储 HDFS 架构：跟大尺度的 RAID。

大数据计算 MapReduce 架构：核心思想是对数据进行分片计算。为了解决数据分散的问题，使用 Key 来组织数据。因为节点计算的结果数据体量已经不大了，这个时候可以把相同 Key 的数据放到一个节点上进一步计算。

大数据仓库 Hive 架构：根据 SQL 自动生成 MapReduce。

快速大数据计算 Spark 架构：MapReduce 主要使用硬盘存储计算过程中的数据，这样虽然可靠性比较高，但是性能其实比较差。Spark 在 MapReduce 基础上进行改进，主要使用内存进行中间计算数据存储，加快了计算执行时间，在某些情况下，性能可以提升上百倍。

大数据流计算架构：Spark是 大数据批处理计算，所以需要实时计算。Spark Streaming（分小批）、Flink。


### AI与物联网架构

大数据底层技术，指的就是各种大数据计算框架、存储系统、SQL 引擎等等，这些技术比较通用，经过十几年的优胜劣汰，主流的技术产品相对比较集中，主要就是 MapReduce、Spark、Hive、Flink 等技术产品。

大数据平台技术，Spark、Hive 这些大数据底层技术产品不像我们前面讨论过的分布式缓存、分布式消息队列，在处理用户请求的应用中，使用这些技术产品的 API 接口就可以了。

大数据计算好的数据应用到：电商常用的智能推荐，用户购买一个商品，系统会推荐可能感兴趣的商品，这些推荐的商品就是大数据计算的结果。

在互联网系统架构中，需要把处理用户请求的在线业务系统和大数据计算系统打通。这就需要一个大数据平台来完成。

大数据平台架构：分为三个部分：数据采集、数据处理和数据输出。

数据主要有两个来源，一方面是应用服务器以及前端 App 实时产生的数据、日志以及埋点采集的数据，另一方面是外部爬虫和第三方数据。

通过大数据平台的数据同步系统，这些数据导入到 HDFS 中。由于不同数据源格式不同，数据源存储系统不同，因此需要针对不同的数据源，开发不同的同步系统。同时，为了能够更好地对写入到 HDFS 的数据进行分析和挖掘，还需要对这些数据进行清洗、转换，因此数据同步系统实际上承担的是传统数据仓库 ETL 的职责，即数据的抽取（Extract）、转换（Transform）、载入（Load）。

写入到 HDFS 的数据会被 MapReduce、Spark、Hive 等大数据计算框架执行。数据分析师、算法工程师提交 SQL 以及 MapReduce 或者 Spark 机器学习程序到大数据平台。大数据平台的计算资源通常总是不足的，因此这些程序需要在任务调度管理系统的调度下排队执行。

SQL 或者机器学习程序的计算结果写回到 HDFS，然后再通过数据同步系统导出到数据库，应用服务器就可以直接访问这些数据，在用户请求的时候为用户提供服务了，比如店铺访问统计数据，或者智能推荐数据等。

所以有了大数据平台，用户产生的数据就会被大数据系统进行各种关联分析与计算，然后又应用于用户请求处理。只不过这个数据可能是历史数据，比如淘宝卖家只能查看 24 小时前的店铺访问统计。

大数据计算也许需要几个小时甚至几天，但是用户有时候可能需要实时得到数据。比如想要看当前的访问统计，那么就需要用到大数据流计算了。来自数据源的数据实时进入大数据流计算引擎 Spark Streaming 等，实时处理后写入数据库。这样卖家既可以看到历史统计数据，又可以看到当前的统计数据。

大数据平台只是提供了数据获取、存储、计算、应用的技术方案，真正挖掘出这些数据之间的关系，让数据发挥价值的是各种机器学习算法。这些各种算法中，最常见的大概就是智能推荐算法了：

- 基于人口统计的推荐：根据用户的基本信息比如年龄进行分类，然后将商品推荐给同类用户。

- 基于商品属性的推荐：根据商品的属性进行分类，然后根据商品分类进行推荐，比如 游戏、电影、追剧。

- 基于用户的协同过滤推荐：根据用户的喜好进行用户分类，然后根据用户分类进行推荐。人以群分。

- 基于商品的协同过滤推荐：根据用户的喜好对商品进行分类，然后根据商品分类进行推荐，物以类聚。

---

物联网架构的关键是终端设备数据的采集、处理与设备的智能控制，背后依然是大数据与 AI 算法。

终端设备负责采集现场数据，这些数据被汇总到智能网关，智能网关经过初步的转换、计算后将数据发送给物联网大数据平台，大数据平台通过消息队列接收发送上来的各种数据。

由于物联网终端设备在现场实时运行，需要实时控制，因此大数据平台也需要实时处理这些数据。大数据流计算引擎会从消息队列中获取数据进行实时处理。

对于一些简单的数据处理来说，流式计算利用配置好的规则进行计算就可以了，而复杂的处理还需要利用机器学习模型。机器学习模型是通过大数据平台离线计算得到的，而离线计算使用的数据则是流计算从消息队列中获取的。

流式计算的结果通常是终端设备的控制信息，这些信息通过设备管理组件被发送给智能网关，智能网关通过边缘计算，产生最终的设备控制信号，控制终端智能设备的动作。而物联网管理人员也可以通过应用程序直接远程控制设备。


### 区块链技术架构

比特币的主要思路是，构建一个无中心、去信任的分布式记账系统。

这个记账系统和传统的银行记账不同，银行的账本由银行自己管理，银行是记账的中心，而比特币则允许任何人参与记账，没有中心，完全分布式的。

传统的银行中心记账必须有个前提，就是交易者都相信银行，信任银行不会伪造、篡改交易。但是任何人都可以参与记账的比特币不可能得到大家的信任，所以这个记账系统必须从设计上实现去信任，也就是不需要信任记账者的身份，却可以信任这个人记的账。

交易签名只能保证交易不是他人伪造的，却不能阻止交易的发起者自己进行多重交易，即交易的发起者将一个比特币同时转账给两个人，也就是所谓的双花。

比特币的解决方案是，记账者在收到若干交易后，会将这些交易打包在一起，形成一个区块（block）。区块必须严格按照顺序产生，因此最新一个区块的记账者可以根据区块顺序得到此前所有的区块。这样，记账者就可以检查所有区块中的交易数据，是否有双花发生。

如何保证区块的严格顺序，比特币的做法是，在每个区块的头部记录他的前一个区块，也就是前驱区块的 hash 值，这样所有的区块就构成了一个链。我们知道，单向链表是有严格顺序的。

通过 hash 值链起来的区块就是所谓的区块链，区块链主要解决 双花 和 交易可回溯 问题。

Hash 值必须难以破解，不然就可以把区块修改，解决方案就是：工作量证明。

在这样的资源消耗要求下，重算所有区块的 hash 值几乎是不可能的，因此，比特币历史交易难以被篡改。这里用了“几乎”这个词，是因为如果有人控制了比特币超过半数的计算资源，确实可以进行交易篡改，即所谓的 51% 攻击。但是这种攻击将会导致比特币崩溃，而能控制这么多计算资源的记账者一定是比特币主要的受益者，他没有必要攻击自己。

矿工：记账和检查账本的目的就需要计算 Hash 然后去比对，这个系统维护工作会得到奖励，相当于一个 Hash 两用：既防盗贼，又促进维护系统。

联盟链：由多个组织共同发起，只有组织成员才能访问的区块链，因此有时候也被称作许可型区块链。

目前比较知名的联盟链技术是 IBM 主导的 Hyperledger Fabric。


## 思维修炼

### 技术修炼之道

- 新手：依然无法独立完成工作，必须在有经验的同事指导下，学习相关的技能。

- 高级新手：差不多掌握了工作的各种套路，可以摆脱新手阶段，独立完成一些基本的工作了。

	在各个专业领域中，超过半数的人终其一生都停留在高级新手阶段。

	高级新手其实是新手的自然延续，他不需要别人指导工作，也不需要学习工作的规则和套路，因为高级新手已经在新手阶段掌握了这些套路，他可以熟练应用这些规则套路完成他的工作。但是高级新手的能力也仅限于此，他不明白这些规则是如何制定出来的，为什么使用这个框架开发而不是另一个框架，也不明白这个框架是如何开发出来的。

	一个重要的原因是：高级新手不知道自己是高级新手。高级新手觉得自己在这个专业领域混得很不错，做事熟练，经验丰富。

- 胜任者：胜任者工作的一个显著特点是，做事具有主动性。他们在遇到新问题时，会积极寻求新的解决方案去解决问题，而不是像高级新手那样，要么束手无策，要么还是用老办法解决新问题，使问题更加恶化。

- 精通者：拥有反思精神和全局思维，即使没有新问题也能够进行自我突破、寻求新的出路的人。精通者需要通过主动学习进行提升，主动进行大量的阅读和培训，而不是仅仅依靠工作中的经验和实践。他们在完成一个工作后会反思：哪些地方可以改进，下次怎么做会更好？

	精通者拥有了自我改进的能力。

- 专家：专家把过往的经验都融汇贯通，然后形成一种直觉，他们直觉地知道事情应该怎么做，然后用最直接、最简单的方法把问题解决。专家通常也是他所在领域的权威，精通者和胜任者会学习、研究专家是如何解决问题的，然后把这种解决方案形成套路，成为行业做事的规则。

---

如何在工作中成长

- 勇于承担责任

- 在实践中保持技能

- 关注问题场景


### 技术进阶之道

我跟一些年轻的软件工程师朋友们交流，关于未来的职业发展，大家普遍都有憧憬和规划，要做架构师，要做技术总监，要做 CTO。对于如何实现自己的职业规划，也都信心满满：努力工作，好好学习，不断提升自己。但现实总是复杂的，日复一日的工作生活总能让人一次又一次地陷入迷茫。其原因之一就是对职业发展轨迹和自我能力进步的一般规律缺乏认识，导致做事找不到方向或是操之过急。

具体看原文，比如段位：

- 行业开创者

- 领域开创者

- 全球影响者

- 全国影响者

- 公司影响者

- 团队影响者


### 技术落地之道

不要把解决方案当作问题的定义，而忽略了真正要解决的问题是什么。

你不需要去解决别人的问题，你只需要提醒他问题的存在。

鱼是最后一个看到水的，身处问题之中的人往往并不觉得有问题。

问题 = 期望 - 体验。


### 技术沟通之道

如果某人能够解决问题，而他自己却感受不到问题，那么就让他感受一下。

通常说来，上司的能力要比你的能力强，调动的资源也比你多，有些事情对你而言可能非常困难，但是你上司也许一句话就可以搞定，这个时候，你可以考虑利用你的上司去解决问题。如果他没有感觉到问题，那么想办法让他感觉到问题。用人的最高境界是用上司。

要批评而不要责难，要对事而不要对人。

如果你想解决一个大家都不关注的问题，那么试试让问题变得更糟。

如果你不填老师想要的答案，你就是个傻瓜。—— 你的努力必须获得上司的认可。


### 技术管理之道

彼得定律：在一个层级组织中，每个员工都会趋向于晋升到他所不能胜任的职位。

一个成熟的组织中，所有的职位都被不能够胜任它的人承担着。

在技术管理领域，常见的管理方式有两种，一种是问题驱动型管理，一种是流程驱动型管理。

问题驱动型管理着眼于问题，每天关注最新的问题是什么，然后解决问题。流程驱动型管理着眼于流程，关注事情的进展是否符合流程规范，是否在有序的规章制度下行事，看起来像监工。

这两种都不是高效的管理方法。对于技术管理而言，更高效的管理方式是目标型管理。

目标驱动的管理者关注的是目标，公司的目标是什么？部门的目标是什么？团队的目标是什么？我的目标是什么？我和我的团队做这些事情的价值和意义是什么？不断问自己：我如何做才能为公司，为客户创造价值？

OKR：Object 目标与 Key Result 关键结果。通过对团队和个人制定有挑战性的目标和可量化的结果标准进行管理。可以说是目标驱动管理的一种落地实践方案。